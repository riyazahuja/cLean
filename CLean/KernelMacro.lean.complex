import Lean
import CLean.GPU
import CLean.VerifyIR

/-! # GPU Kernel Macro with Automatic IR Extraction

Provides `gpu_kernel` macro that generates both executable KernelM and VKernel IR.
Works by parsing surface syntax before elaboration, avoiding bound variable issues.
-/

open Lean Lean.Elab Lean.Elab.Command Lean.Parser.Term
open CLean.VerifyIR GpuDSL

namespace CLean.KernelMacro

/-! ## Context for tracking extraction state -/

structure ExtractCtx where
  globalArrays : Array Name := #[]  -- Track global array names
  sharedArrays : Array Name := #[]  -- Track shared array names
  localVars : Array Name := #[]     -- Track local variable names
  arrayMap : Std.HashMap String Name := {}  -- Map local var to actual array name

/-! ## Expression Conversion -/

/-- Convert term syntax to VExpr syntax -/
partial def exprToVExpr (stx : Syntax) : MacroM Syntax := do
  match stx with
  -- Identifiers
  | `($id:ident) =>
    let name := id.getId
    if name == `globalIdxX then
      `(VExpr.add (VExpr.mul VExpr.blockIdX VExpr.blockDimX) VExpr.threadIdX)
    else if name == `globalIdxY then
      `(VExpr.add (VExpr.mul VExpr.blockIdY VExpr.blockDimY) VExpr.threadIdY)
    else if name == `threadIdX then
      `(VExpr.threadIdX)
    else if name == `blockIdX then
      `(VExpr.blockIdX)
    else if name == `blockDimX then
      `(VExpr.blockDimX)
    else
      `(VExpr.var $(quote name))

  -- Numeric literals
  | `($n:num) =>
    let val := n.getNat
    `(VExpr.constInt $(Syntax.mkNumLit (toString val)))

  -- Field access (e.g., args.N)
  | `($obj:ident.$field:ident) =>
    if obj.getId == `args then
      `(VExpr.var $(quote field.getId))
    else
      `(VExpr.var $(quote field.getId))

  -- Binary operations - build manually
  | `($a:term + $b:term) => do
    let ae ← exprToVExpr a
    let be ← exprToVExpr b
    let res ← `(VExpr.add _ _)
    pure <| res.raw.modifyArg 1 (fun _ => ae) |>.modifyArg 2 (fun _ => be)

  | `($a:term - $b:term) => do
    let ae ← exprToVExpr a
    let be ← exprToVExpr b
    let res ← `(VExpr.sub _ _)
    pure <| res.raw.modifyArg 1 (fun _ => ae) |>.modifyArg 2 (fun _ => be)

  | `($a:term * $b:term) => do
    let ae ← exprToVExpr a
    let be ← exprToVExpr b
    let res ← `(VExpr.mul _ _)
    pure <| res.raw.modifyArg 1 (fun _ => ae) |>.modifyArg 2 (fun _ => be)

  | `($a:term / $b:term) => do
    let ae ← exprToVExpr a
    let be ← exprToVExpr b
    let res ← `(VExpr.div _ _)
    pure <| res.raw.modifyArg 1 (fun _ => ae) |>.modifyArg 2 (fun _ => be)

  | `($a:term % $b:term) => do
    let ae ← exprToVExpr a
    let be ← exprToVExpr b
    let res ← `(VExpr.mod _ _)
    pure <| res.raw.modifyArg 1 (fun _ => ae) |>.modifyArg 2 (fun _ => be)

  -- Comparisons
  | `($a:term < $b:term) => do
    let ae ← exprToVExpr a
    let be ← exprToVExpr b
    let res ← `(VExpr.lt _ _)
    pure <| res.raw.modifyArg 1 (fun _ => ae) |>.modifyArg 2 (fun _ => be)

  | `($a:term <= $b:term) => do
    let ae ← exprToVExpr a
    let be ← exprToVExpr b
    let res ← `(VExpr.le _ _)
    pure <| res.raw.modifyArg 1 (fun _ => ae) |>.modifyArg 2 (fun _ => be)

  | `($a:term == $b:term) => do
    let ae ← exprToVExpr a
    let be ← exprToVExpr b
    let res ← `(VExpr.eq _ _)
    pure <| res.raw.modifyArg 1 (fun _ => ae) |>.modifyArg 2 (fun _ => be)

  -- Logical operations
  | `($a:term && $b:term) => do
    let ae ← exprToVExpr a
    let be ← exprToVExpr b
    let res ← `(VExpr.land _ _)
    pure <| res.raw.modifyArg 1 (fun _ => ae) |>.modifyArg 2 (fun _ => be)

  | `($a:term || $b:term) => do
    let ae ← exprToVExpr a
    let be ← exprToVExpr b
    let res ← `(VExpr.lor _ _)
    pure <| res.raw.modifyArg 1 (fun _ => ae) |>.modifyArg 2 (fun _ => be)

  -- Parenthesized expressions
  | `(($e:term)) => exprToVExpr e

  -- Default: treat as unknown variable
  | _ => `(VExpr.var `unknown)

/-! ## Statement Extraction -/

/-- Helper: Extract items from a do-sequence branch -/
def getDoSeqItems (branch : TSyntax `Lean.Parser.Term.doSeq) : Array Syntax :=
  let seq := branch.raw[1]  -- doSeqIndent or doSeqBracketed
  if seq.getArgs.size >= 1 then
    seq[0].getArgs  -- Array of doSeqItems
  else
    #[]

/-- Extract VStmt list from do-sequence items -/
partial def extractDoItems (items : Array Syntax) (ctx : ExtractCtx) : MacroM (Array Syntax × ExtractCtx) := do
  let mut vstmts : Array Syntax := #[]
  let mut newCtx := ctx

  for item in items do
    -- Each item is a doSeqItem, extract the doElem
    if item.getKind != ``Lean.Parser.Term.doSeqItem then
      continue

    let doElem := item[0]

    -- Process each pattern
    if let `(doElem| let $id:ident ← globalIdxX) := doElem then
      -- let i ← globalIdxX
      let varName := id.getId
      let vstmt ← `({ stmt := VStmtKind.assign $(quote varName)
                        (VExpr.add (VExpr.mul VExpr.blockIdX VExpr.blockDimX) VExpr.threadIdX),
                      predicate := VExpr.constBool true })
      vstmts := vstmts.push vstmt
      newCtx := { newCtx with localVars := newCtx.localVars.push varName }
    else if let `(doElem| let $id:ident ← globalIdxY) := doElem then
      -- let i ← globalIdxY
      let varName := id.getId
      let vstmt ← `({ stmt := VStmtKind.assign $(quote varName)
                        (VExpr.add (VExpr.mul VExpr.blockIdY VExpr.blockDimY) VExpr.threadIdY),
                      predicate := VExpr.constBool true })
      vstmts := vstmts.push vstmt
      newCtx := { newCtx with localVars := newCtx.localVars.push varName }
    else if let `(doElem| barrier) := doElem then
      -- barrier
      let vstmt ← `({ stmt := VStmtKind.barrier, predicate := VExpr.constBool true })
      vstmts := vstmts.push vstmt

    -- Array declarations: let x : GlobalArray T := ⟨args.field⟩
    else if let `(doElem| let $id:ident : GlobalArray $_ := ⟨$rhs:term⟩) := doElem then
      let varName := id.getId
      -- Extract field name from args.field
      if let `($argsId:ident.$field:ident) := rhs then
        if argsId.getId == `args then
          let fieldName := field.getId
          newCtx := { newCtx with
            globalArrays := newCtx.globalArrays.push fieldName,
            arrayMap := newCtx.arrayMap.insert (varName.toString) fieldName
          }
        else
          pure ()
      else
        pure ()

    -- Array declarations: let x : SharedArray T := ⟨args.field⟩
    else if let `(doElem| let $id:ident : SharedArray $_ := ⟨$rhs:term⟩) := doElem then
      let varName := id.getId
      -- Extract field name from args.field
      if let `($argsId:ident.$field:ident) := rhs then
        if argsId.getId == `args then
          let fieldName := field.getId
          newCtx := { newCtx with
            sharedArrays := newCtx.sharedArrays.push fieldName,
            arrayMap := newCtx.arrayMap.insert (varName.toString) fieldName
          }
        else
          pure ()
      else
        pure ()

    -- Simple let bindings: let x := expr (for args extraction, scalars, etc.)
    else if let `(doElem| let $id:ident := $rhs:term) := doElem then
      -- Could be args extraction (let args ← getArgs becomes let args := ...)
      -- or scalar field access (let N := args.N)
      -- For now, just skip - we don't track these in VKernel
      pure ()

    -- Let with arrow: let x ← expr
    else if let `(doElem| let $id:ident ← $rhs:term) := doElem then
      -- Check if rhs is getArgs (special case)
      if rhs.raw.isIdent && rhs.raw.getId == `getArgs then
        -- let args ← getArgs - skip, don't track
        pure ()
      -- Check if rhs is a method call (could be array.get)
      else if rhs.raw.getKind == ``Lean.Parser.Term.app then
        -- Try to parse as arr.get idx
        let fn := rhs.raw.getArg 0
        if fn.getKind == ``Lean.Parser.Term.proj then
          let arr := fn.getArg 0
          let method := fn.getArg 2
          if method.isIdent && method.getId == `get && arr.isIdent then
            -- This is arr.get idx
            let valName := id.getId
            let arrName := arr.getId
            let actualArrayName := newCtx.arrayMap.getD (arrName.toString) arrName
            -- Get the index from the app arguments
            let args := rhs.raw.getArg 2
            if args.getKind == `null && args.getNumArgs > 0 then
              let idx := args.getArg 0
              let idxVExpr ← exprToVExpr (TSyntax.mk idx)
              -- Build memory location and read statement
              let memSpace := if newCtx.sharedArrays.contains actualArrayName then
                `(MemorySpace.shared)
              else
                `(MemorySpace.global)
              let vstmt ← `({ stmt := VStmtKind.read
                                { array := $(quote actualArrayName),
                                  index := $(pure idxVExpr),
                                  memorySpace := $memSpace }
                                $(quote valName),
                              predicate := VExpr.constBool true })
              vstmts := vstmts.push vstmt
              newCtx := { newCtx with localVars := newCtx.localVars.push valName }
            else
              pure ()
          else
            -- Not array.get, try general assignment
            let varName := id.getId
            let exprVExpr ← exprToVExpr rhs
            let vstmt ← `({ stmt := VStmtKind.assign $(quote varName) $(pure exprVExpr),
                            predicate := VExpr.constBool true })
            vstmts := vstmts.push vstmt
            newCtx := { newCtx with localVars := newCtx.localVars.push varName }
        else
          -- Not projection, try general assignment
          let varName := id.getId
          let exprVExpr ← exprToVExpr rhs
          let vstmt ← `({ stmt := VStmtKind.assign $(quote varName) $(pure exprVExpr),
                          predicate := VExpr.constBool true })
          vstmts := vstmts.push vstmt
          newCtx := { newCtx with localVars := newCtx.localVars.push varName }
      else
        -- General let x ← expr - treat as assignment
        let varName := id.getId
        let exprVExpr ← exprToVExpr rhs
        let vstmt ← `({ stmt := VStmtKind.assign $(quote varName) $(pure exprVExpr),
                        predicate := VExpr.constBool true })
        vstmts := vstmts.push vstmt
        newCtx := { newCtx with localVars := newCtx.localVars.push varName }

    -- Expression statements: check if it's arr.set idx val
    else if doElem.getKind == ``Lean.Parser.Term.doExpr then
      -- doExpr wraps a term - extract it
      let expr := doElem.getArg 0
      -- Check if it's a method call
      if expr.getKind == ``Lean.Parser.Term.app then
        let fn := expr.getArg 0
        if fn.getKind == ``Lean.Parser.Term.proj then
          let arr := fn.getArg 0
          let method := fn.getArg 2
          if method.isIdent && method.getId == `set && arr.isIdent then
            -- This is arr.set idx val
            let arrName := arr.getId
            let actualArrayName := newCtx.arrayMap.getD (arrName.toString) arrName
            -- Get the arguments (idx and val)
            let args := expr.getArg 2
            if args.getKind == `null && args.getNumArgs >= 2 then
              let idx := args.getArg 0
              let val := args.getArg 1
              let idxVExpr ← exprToVExpr (TSyntax.mk idx)
              let valVExpr ← exprToVExpr (TSyntax.mk val)
              let memSpace := if newCtx.sharedArrays.contains actualArrayName then
                `(MemorySpace.shared)
              else
                `(MemorySpace.global)
              let vstmt ← `({ stmt := VStmtKind.write
                                { array := $(quote actualArrayName),
                                  index := $(pure idxVExpr),
                                  memorySpace := $memSpace }
                                $(pure valVExpr),
                              predicate := VExpr.constBool true })
              vstmts := vstmts.push vstmt
            else
              pure ()
          else
            pure ()
        else
          pure ()
      else
        pure ()

    -- If-then-else: if cond then ... else ...
    else if let `(doElem| if $cond:term then $thenBranch:term $[else $elseBranch:term]?) := doElem then
      let condVExpr ← exprToVExpr cond

      -- Extract then branch statements
      let (thenStmts, _) ← if thenBranch.raw.getKind == ``Lean.Parser.Term.do then
        let items := getDoSeqItems ⟨thenBranch.raw⟩
        extractDoItems items newCtx
      else
        -- Single statement, not a do block - skip for now
        pure (#[], newCtx)

      -- Extract else branch statements if present
      let elseStmts ← match elseBranch with
        | some eb => do
          let (stmts, _) ← if eb.raw.getKind == ``Lean.Parser.Term.do then
            let items := getDoSeqItems ⟨eb.raw⟩
            extractDoItems items newCtx
          else
            pure (#[], newCtx)
          pure stmts
        | none => pure #[]

      -- Build if-then-else statement
      -- Build list syntax from arrays (stmt is already Syntax)
      let mut thenListStx ← `([])
      for stmt in thenStmts.reverse do
        let stmtTSyntax : TSyntax `term := ⟨stmt⟩
        thenListStx ← `($stmtTSyntax :: $thenListStx)
      let mut elseListStx ← `([])
      for stmt in elseStmts.reverse do
        let stmtTSyntax : TSyntax `term := ⟨stmt⟩
        elseListStx ← `($stmtTSyntax :: $elseListStx)
      let vstmt ← `({ stmt := VStmtKind.ite $(pure condVExpr) $thenListStx $elseListStx,
                      predicate := VExpr.constBool true })
      vstmts := vstmts.push vstmt

    else
      -- Skip other patterns for now
      pure ()

  return (vstmts, newCtx)

/-! ## Main Macro -/

/-- The gpu_kernel macro - generates both KernelM definition and VKernel IR -/
macro "gpu_kernel " name:ident sig:optDeclSig val:declVal : command => do
  -- Extract the body
  let body ← match val with
    | `(declVal| := $body:term) => pure body
    | _ => Macro.throwError "Expected := body"

  -- Check if it's do-notation (skip for now)
  -- if body.raw.getKind != ``Lean.Parser.Term.do then
  --   Macro.throwError "Expected do-notation body"

  -- Extract do-sequence items
  let doSeq := body.raw[1]  -- doSeqIndent or doSeqBracketed
  let items := if doSeq.getArgs.size >= 1 then
      doSeq[0].getArgs
    else
      #[]

  -- Extract statements and track arrays/vars
  let (vstmts, extractCtx) ← extractDoItems items {}

  -- Build VarInfo syntax for global arrays
  let mut globalArraySyntax : Array Syntax := #[]
  for arrName in extractCtx.globalArrays do
    let s ← `({ name := $(quote arrName), type := VType.float,
                uniformity := Uniformity.uniform, memorySpace := MemorySpace.global })
    globalArraySyntax := globalArraySyntax.push s

  -- Build VarInfo syntax for shared arrays
  let mut sharedArraySyntax : Array Syntax := #[]
  for arrName in extractCtx.sharedArrays do
    let s ← `({ name := $(quote arrName), type := VType.float,
                uniformity := Uniformity.uniform, memorySpace := MemorySpace.shared })
    sharedArraySyntax := sharedArraySyntax.push s

  -- Build VarInfo syntax for local variables
  let mut localsSyntax : Array Syntax := #[]
  for varName in extractCtx.localVars do
    let s ← `({ name := $(quote varName), type := VType.nat,
                uniformity := Uniformity.nonUniform, memorySpace := MemorySpace.local })
    localsSyntax := localsSyntax.push s

  -- Generate the KernelM definition (unchanged from original)
  let kernelDefStx ← `(def $name $sig:optDeclSig $val:declVal)

  -- Generate the VKernel IR definition
  let irName := Lean.mkIdent (name.getId.appendAfter "IR")
  let nameQuote := quote name.getId

  -- Build list syntax for VKernel fields (v is already Syntax)
  let mut localsListStx ← `([])
  for v in localsSyntax.reverse do
    let vTSyntax : TSyntax `term := ⟨v⟩
    localsListStx ← `($vTSyntax :: $localsListStx)
  let mut globalArraysListStx ← `([])
  for v in globalArraySyntax.reverse do
    let vTSyntax : TSyntax `term := ⟨v⟩
    globalArraysListStx ← `($vTSyntax :: $globalArraysListStx)
  let mut sharedArraysListStx ← `([])
  for v in sharedArraySyntax.reverse do
    let vTSyntax : TSyntax `term := ⟨v⟩
    sharedArraysListStx ← `($vTSyntax :: $sharedArraysListStx)
  let mut bodyListStx ← `([])
  for v in vstmts.reverse do
    let vTSyntax : TSyntax `term := ⟨v⟩
    bodyListStx ← `($vTSyntax :: $bodyListStx)

  -- Build VKernel IR definition
  let vkernelDefStx ← `(
    def $irName : CLean.VerifyIR.VKernel := {
      name := $nameQuote
      params := []
      locals := $localsListStx
      globalArrays := $globalArraysListStx
      sharedArrays := $sharedArraysListStx
      body := $bodyListStx
    }
  )

  -- Return both definitions as a command sequence
  `($kernelDefStx:command
    $vkernelDefStx:command)

end CLean.KernelMacro
